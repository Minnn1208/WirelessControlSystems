C51 COMPILER V9.00   TIMER_WITHKEY2                                                        10/24/2023 16:20:51 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE TIMER_WITHKEY2
OBJECT MODULE PLACED IN .\Objects\timer_withKey2.obj
COMPILER INVOKED BY: E:\Keil4\C51\BIN\C51.EXE ..\秒表\timer_withKey2.c BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\timer_
                    -withKey2.lst) OBJECT(.\Objects\timer_withKey2.obj)

line level    source

   1          #include "reg52.h"
   2          
   3          typedef unsigned int u16;
   4          typedef unsigned char u8;
   5          
   6          sbit LSA=P2^2;
   7          sbit LSB=P2^3;
   8          sbit LSC=P2^4;
   9          
  10          sbit K1=P3^1; //开始
  11          sbit K2=P3^0; //开始
  12          
  13          u8 code smgduan[17]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,
  14          0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};//导入数码管段码
  15          
  16          u8 ssec,sec,min; //毫秒 秒 分
  17          u8 DisplayData[8]; //8个显示的数字放在一个数组里
  18          
  19          void delay(u16 i)
  20          {
  21   1      while(i--);
  22   1      }
  23          
  24          void Timer0Init() //定时器0的初始化
  25          {
  26   1      TMOD|=0X01; //对TMOD赋值 0000 0001：工作方式0，仅启用TR0
  27   1      //TH0=0Xd8; //定时时长10ms，前四位d8，后四位f0
  28   1      //TL0=0Xf0;
  29   1      TH0=(65536-16300)/256;
  30   1      TL0=(65536-16300)%256;
  31   1      ET0=1; //打开T0中断
  32   1      EA=1; //打开总中断
  33   1      TR0=1; //打开定时器计数
  34   1      }
  35          
  36          void DigDisplay() //数码管动态扫描函数，循环扫描8个数码管显示
  37          {
  38   1      u8 i;
  39   1      for(i=0;i<8;i++)
  40   1      {
  41   2      switch(i) //i：位数
  42   2      {
  43   3      case(0):
  44   3      LSA=1;LSB=1;LSC=1; break;//第7位
  45   3      case(1):
  46   3      LSA=0;LSB=1;LSC=1; break;//第6位
  47   3      case(2):
  48   3      LSA=1;LSB=0;LSC=1; break;//第5位
  49   3      case(3):
  50   3      LSA=0;LSB=0;LSC=1; break;//第4位
  51   3      case(4):
  52   3      LSA=1;LSB=1;LSC=0; break;//第3位
  53   3      case(5):
  54   3      LSA=0;LSB=1;LSC=0; break;//第2位
C51 COMPILER V9.00   TIMER_WITHKEY2                                                        10/24/2023 16:20:51 PAGE 2   

  55   3      case(6):
  56   3      LSA=1;LSB=0;LSC=0; break;//第1位
  57   3      case(7):
  58   3      LSA=0;LSB=0;LSC=0;break; // 0
  59   3      }
  60   2      P0=DisplayData[i]; //发送段码
  61   2      delay(0); //人眼视觉暂留
  62   2      P0=0x00; //消影
  63   2      }
  64   1      }
  65          
  66          void datapros()
  67          {
  68   1      DisplayData[0]=0x3f;
  69   1      DisplayData[1]=smgduan[min/10];
  70   1      DisplayData[2]=smgduan[min%10];
  71   1      DisplayData[3]=0x40;
  72   1      DisplayData[4]=smgduan[sec/10];
  73   1      DisplayData[5]=smgduan[sec%10]|0x80;
  74   1      DisplayData[6]=smgduan[ssec/10];
  75   1      DisplayData[7]=smgduan[ssec%10];
  76   1      }
  77          void main()
  78          {
  79   1      Timer0Init(); //定时器0初始化
  80   1      while(1)
  81   1      {
  82   2              if(K1 != 1){
  83   3                      if(K2 == 0){
  84   4                              EA = 0;          //总中断关闭
  85   4                      }
  86   3                      datapros();
  87   3                      DigDisplay();
  88   3              }
  89   2      }
  90   1      }
  91          
  92          void Timer0() interrupt 1 //定时器0中断函数
  93          {
  94   1      //TH0=0Xd8;
  95   1      //TL0=0Xf0;
  96   1      TH0=(65536-16300)/256;
  97   1      TL0=(65536-16300)%256;
  98   1      delay(100);
  99   1      ssec++;
 100   1      if(ssec>=100) //1s
 101   1      {
 102   2      ssec=0;
 103   2      sec++;
 104   2      if(sec>=60)
 105   2      {
 106   3      sec=0;
 107   3      min++;
 108   3      if(min>=60)
 109   3      {
 110   4      min=0;
 111   4      }
 112   3      }
 113   2      }
 114   1      }
 115          

C51 COMPILER V9.00   TIMER_WITHKEY2                                                        10/24/2023 16:20:51 PAGE 3   


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    297    ----
   CONSTANT SIZE    =     17    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     11    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
